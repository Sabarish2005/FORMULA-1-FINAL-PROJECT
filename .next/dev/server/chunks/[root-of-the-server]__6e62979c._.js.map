{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Admin/OneDrive/Pictures/FORMULA%201%20FINAL%20PROJECT/lib/f1-data-loader.ts"],"sourcesContent":["import fs from \"fs\"\nimport path from \"path\"\nimport { parse } from \"csv-parse/sync\"\n\n// Types for F1 data\nexport interface Driver {\n  driverId: number\n  driverRef: string\n  number?: number\n  code?: string\n  forename: string\n  surname: string\n  dob?: string\n  nationality: string\n}\n\nexport interface Constructor {\n  constructorId: number\n  constructorRef: string\n  name: string\n  nationality: string\n}\n\nexport interface Race {\n  raceId: number\n  year: number\n  round: number\n  circuitId: number\n  name: string\n  date: string\n  time?: string\n}\n\nexport interface Result {\n  resultId: number\n  raceId: number\n  driverId: number\n  constructorId: number\n  number?: number\n  grid: number\n  position?: number\n  positionText: string\n  positionOrder: number\n  points: number\n  laps: number\n  time?: string\n  milliseconds?: number\n  fastestLap?: number\n  rank?: number\n  fastestLapTime?: string\n  fastestLapSpeed?: string\n  statusId: number\n}\n\nexport interface Circuit {\n  circuitId: number\n  circuitRef: string\n  name: string\n  location: string\n  country: string\n  lat?: number\n  lng?: number\n  alt?: number\n}\n\nexport interface Season {\n  year: number\n  url?: string\n}\n\nexport interface QualiResult {\n  qualifyId: number\n  raceId: number\n  driverId: number\n  constructorId: number\n  number: number\n  position?: number\n  q1?: string\n  q2?: string\n  q3?: string\n}\n\n// Singleton cache\nlet cachedData: {\n  drivers: Map<number, Driver>\n  constructors: Map<number, Constructor>\n  races: Race[]\n  results: Result[]\n  circuits: Map<number, Circuit>\n  seasons: Season[]\n  qualifying: QualiResult[]\n} | null = null\n\nfunction parseCsvFile<T>(fileName: string): T[] {\n  try {\n    const filePath = path.join(process.cwd(), \"public\", \"data\", fileName)\n\n    if (!fs.existsSync(filePath)) {\n      console.warn(`[F1 Data] CSV file not found: ${fileName}`)\n      return []\n    }\n\n    const fileContent = fs.readFileSync(filePath, \"utf-8\")\n    const records = parse(fileContent, {\n      columns: true,\n      skip_empty_lines: true,\n      cast: (value, context) => {\n        // Auto-convert numeric fields\n        if (context.header) return value\n        if (value === \"\" || value === null) return null\n        if (!isNaN(Number(value)) && value !== \"\") return Number(value)\n        return value\n      },\n    })\n\n    return records as T[]\n  } catch (error) {\n    console.error(`[F1 Data] Error parsing ${fileName}:`, error)\n    return []\n  }\n}\n\nfunction generateMockData() {\n  const mockDrivers = new Map<number, Driver>([\n    [1, { driverId: 1, driverRef: \"hamilton\", forename: \"Lewis\", surname: \"Hamilton\", nationality: \"British\" }],\n    [2, { driverId: 2, driverRef: \"verstappen\", forename: \"Max\", surname: \"Verstappen\", nationality: \"Dutch\" }],\n    [3, { driverId: 3, driverRef: \"alonso\", forename: \"Fernando\", surname: \"Alonso\", nationality: \"Spanish\" }],\n    [4, { driverId: 4, driverRef: \"leclerc\", forename: \"Charles\", surname: \"Leclerc\", nationality: \"Monegasque\" }],\n    [5, { driverId: 5, driverRef: \"sainz\", forename: \"Carlos\", surname: \"Sainz\", nationality: \"Spanish\" }],\n  ])\n\n  const mockConstructors = new Map<number, Constructor>([\n    [1, { constructorId: 1, constructorRef: \"mercedes\", name: \"Mercedes\", nationality: \"German\" }],\n    [2, { constructorId: 2, constructorRef: \"red_bull\", name: \"Red Bull Racing\", nationality: \"Austrian\" }],\n    [3, { constructorId: 3, constructorRef: \"ferrari\", name: \"Ferrari\", nationality: \"Italian\" }],\n    [4, { constructorId: 4, constructorRef: \"mclaren\", name: \"McLaren\", nationality: \"British\" }],\n  ])\n\n  const mockCircuits = new Map<number, Circuit>([\n    [1, { circuitId: 1, circuitRef: \"monza\", name: \"Monza\", location: \"Monza\", country: \"Italy\" }],\n    [2, { circuitId: 2, circuitRef: \"silverstone\", name: \"Silverstone\", location: \"Silverstone\", country: \"UK\" }],\n  ])\n\n  const mockRaces: Race[] = Array.from({ length: 20 }, (_, i) => ({\n    raceId: i + 1,\n    year: 2024,\n    round: i + 1,\n    circuitId: (i % 2) + 1,\n    name: `Grand Prix ${i + 1}`,\n    date: \"2024-01-01\",\n  }))\n\n  const mockResults: Result[] = []\n  const mockSeasons: Season[] = Array.from({ length: 75 }, (_, i) => ({\n    year: 1950 + i,\n  }))\n\n  return {\n    drivers: mockDrivers,\n    constructors: mockConstructors,\n    races: mockRaces,\n    results: mockResults,\n    circuits: mockCircuits,\n    seasons: mockSeasons,\n    qualifying: [],\n  }\n}\n\nexport async function loadF1Data() {\n  // Return cached data if available\n  if (cachedData) {\n    return cachedData\n  }\n\n  try {\n    // Load all CSV files\n    const drivers = parseCsvFile<Driver>(\"drivers.csv\")\n    const constructors = parseCsvFile<Constructor>(\"constructors.csv\")\n    const races = parseCsvFile<Race>(\"races.csv\")\n    const results = parseCsvFile<Result>(\"results.csv\")\n    const circuits = parseCsvFile<Circuit>(\"circuits.csv\")\n    const seasons = parseCsvFile<Season>(\"seasons.csv\")\n    const qualifying = parseCsvFile<QualiResult>(\"qualifying.csv\")\n\n    // Check if we got any real data\n    const hasRealData = drivers.length > 0 || races.length > 0 || results.length > 0\n\n    if (!hasRealData) {\n      console.warn(\"[F1 Data] No CSV files found, using mock data\")\n      cachedData = generateMockData()\n      return cachedData\n    }\n\n    // Create maps for O(1) lookups\n    const driverMap = new Map(drivers.map((d) => [d.driverId, d]))\n    const constructorMap = new Map(constructors.map((c) => [c.constructorId, c]))\n    const circuitMap = new Map(circuits.map((c) => [c.circuitId, c]))\n\n    cachedData = {\n      drivers: driverMap,\n      constructors: constructorMap,\n      races,\n      results,\n      circuits: circuitMap,\n      seasons,\n      qualifying,\n    }\n\n    return cachedData\n  } catch (error) {\n    console.error(\"[F1 Data] Error loading data, using mock data:\", error)\n    cachedData = generateMockData()\n    return cachedData\n  }\n}\n\n// Helper functions\nexport async function getSeasonRaces(year: number) {\n  const data = await loadF1Data()\n  return data.races.filter((r) => r.year === year).sort((a, b) => a.round - b.round)\n}\n\nexport async function getDriverStandings(year: number) {\n  const data = await loadF1Data()\n  const races = await getSeasonRaces(year)\n\n  if (races.length === 0) {\n    return []\n  }\n\n  const raceIds = new Set(races.map((r) => r.raceId))\n\n  const seasonResults = data.results.filter((r) => raceIds.has(r.raceId))\n\n  const standings: Record<number, { driverId: number; points: number; wins: number; poles: number }> = {}\n\n  seasonResults.forEach((result) => {\n    if (!standings[result.driverId]) {\n      standings[result.driverId] = { driverId: result.driverId, points: 0, wins: 0, poles: 0 }\n    }\n    standings[result.driverId].points += result.points\n    if (result.positionOrder === 1) standings[result.driverId].wins++\n  })\n\n  const quali = data.qualifying.filter((q) => raceIds.has(q.raceId))\n  quali.forEach((q) => {\n    if (q.position === 1 && standings[q.driverId]) {\n      standings[q.driverId].poles++\n    }\n  })\n\n  return Object.values(standings)\n    .sort((a, b) => b.points - a.points)\n    .map((standing) => ({\n      ...standing,\n      driver: data.drivers.get(standing.driverId),\n    }))\n}\n\nexport async function getConstructorStandings(year: number) {\n  const data = await loadF1Data()\n  const races = await getSeasonRaces(year)\n\n  if (races.length === 0) {\n    return []\n  }\n\n  const raceIds = new Set(races.map((r) => r.raceId))\n\n  const seasonResults = data.results.filter((r) => raceIds.has(r.raceId))\n\n  const standings: Record<number, { constructorId: number; points: number; wins: number }> = {}\n\n  seasonResults.forEach((result) => {\n    if (!standings[result.constructorId]) {\n      standings[result.constructorId] = { constructorId: result.constructorId, points: 0, wins: 0 }\n    }\n    standings[result.constructorId].points += result.points\n    if (result.positionOrder === 1) standings[result.constructorId].wins++\n  })\n\n  return Object.values(standings)\n    .sort((a, b) => b.points - a.points)\n    .map((standing) => ({\n      ...standing,\n      constructor: data.constructors.get(standing.constructorId),\n    }))\n}\n\nexport async function getDriverCareerStats(driverId: number) {\n  const data = await loadF1Data()\n  const driverResults = data.results.filter((r) => r.driverId === driverId)\n\n  const stats = {\n    wins: driverResults.filter((r) => r.positionOrder === 1).length,\n    podiums: driverResults.filter((r) => r.positionOrder <= 3).length,\n    points: driverResults.reduce((sum, r) => sum + r.points, 0),\n    races: driverResults.length,\n    dnfs: driverResults.filter((r) => !r.position || r.position === null).length,\n  }\n\n  return stats\n}\n\nexport async function getConstructorCareerStats(constructorId: number) {\n  const data = await loadF1Data()\n  const constructorResults = data.results.filter((r) => r.constructorId === constructorId)\n\n  const stats = {\n    wins: constructorResults.filter((r) => r.positionOrder === 1).length,\n    championships: 0, // Would need season-based logic\n    points: constructorResults.reduce((sum, r) => sum + r.points, 0),\n    races: constructorResults.length,\n  }\n\n  return stats\n}\n\nexport async function getAllTimeRecords() {\n  const data = await loadF1Data()\n\n  // Most wins by driver\n  const driverWins = new Map<number, number>()\n  data.results.forEach((r) => {\n    if (r.positionOrder === 1) {\n      driverWins.set(r.driverId, (driverWins.get(r.driverId) || 0) + 1)\n    }\n  })\n\n  // Most wins by constructor\n  const constructorWins = new Map<number, number>()\n  data.results.forEach((r) => {\n    if (r.positionOrder === 1) {\n      constructorWins.set(r.constructorId, (constructorWins.get(r.constructorId) || 0) + 1)\n    }\n  })\n\n  // Most poles by driver\n  const driverPoles = new Map<number, number>()\n  data.qualifying.forEach((q) => {\n    if (q.position === 1) {\n      driverPoles.set(q.driverId, (driverPoles.get(q.driverId) || 0) + 1)\n    }\n  })\n\n  return {\n    driverWins: Array.from(driverWins.entries())\n      .map(([driverId, wins]) => ({ driverId, wins, driver: data.drivers.get(driverId) }))\n      .sort((a, b) => b.wins - a.wins)\n      .slice(0, 20),\n    constructorWins: Array.from(constructorWins.entries())\n      .map(([constructorId, wins]) => ({ constructorId, wins, constructor: data.constructors.get(constructorId) }))\n      .sort((a, b) => b.wins - a.wins)\n      .slice(0, 15),\n    driverPoles: Array.from(driverPoles.entries())\n      .map(([driverId, poles]) => ({ driverId, poles, driver: data.drivers.get(driverId) }))\n      .sort((a, b) => b.poles - a.poles)\n      .slice(0, 20),\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Admin/OneDrive/Pictures/FORMULA%201%20FINAL%20PROJECT/app/api/season/%5Byear%5D/route.ts"],"sourcesContent":["import { getSeasonRaces, getDriverStandings, getConstructorStandings } from \"@/lib/f1-data-loader\"\n\nexport async function GET(request: Request, { params }: { params: Promise<{ year: string }> }) {\n  try {\n    const { year } = await params\n    const yearNum = Number.parseInt(year)\n\n    let races: any[] = []\n    let driverStandings: any[] = []\n    let constructorStandings: any[] = []\n\n    try {\n      races = await getSeasonRaces(yearNum)\n      driverStandings = await getDriverStandings(yearNum)\n      constructorStandings = await getConstructorStandings(yearNum)\n    } catch (error) {\n      console.error(`[API] Error loading data for ${yearNum}, using mock data`)\n    }\n\n    // Generate mock data if real data is empty\n    if (races.length === 0) {\n      const numRaces = yearNum < 1960 ? 8 : yearNum < 1980 ? 15 : yearNum < 2000 ? 16 : yearNum < 2010 ? 17 : 21\n      races = Array.from({ length: numRaces }, (_, i) => ({\n        raceId: `${yearNum}_${i + 1}`,\n        round: i + 1,\n        name:\n          [\n            \"Australian Grand Prix\",\n            \"Bahrain Grand Prix\",\n            \"Chinese Grand Prix\",\n            \"Azerbaijan Grand Prix\",\n            \"Miami Grand Prix\",\n            \"Monaco Grand Prix\",\n            \"Spanish Grand Prix\",\n            \"Canadian Grand Prix\",\n            \"Austrian Grand Prix\",\n            \"British Grand Prix\",\n            \"Hungarian Grand Prix\",\n            \"Belgian Grand Prix\",\n            \"Dutch Grand Prix\",\n            \"Italian Grand Prix\",\n            \"Singapore Grand Prix\",\n            \"Japanese Grand Prix\",\n            \"Qatar Grand Prix\",\n            \"United States Grand Prix\",\n            \"Mexico City Grand Prix\",\n            \"Brazilian Grand Prix\",\n            \"Abu Dhabi Grand Prix\",\n          ][i] || `Grand Prix ${i + 1}`,\n        date: `${yearNum}-${String(i + 1).padStart(2, \"0\")}-${String(Math.floor(Math.random() * 28) + 1).padStart(2, \"0\")}`,\n        circuitId: `circuit_${i + 1}`,\n      }))\n    }\n\n    if (driverStandings.length === 0) {\n      const drivers = [\n        \"Max Verstappen\",\n        \"Lewis Hamilton\",\n        \"Charles Leclerc\",\n        \"Sergio Perez\",\n        \"Carlos Sainz\",\n        \"Lando Norris\",\n        \"George Russell\",\n        \"Fernando Alonso\",\n        \"Oscar Piastri\",\n        \"Lance Stroll\",\n        \"Pierre Gasly\",\n        \"Esteban Ocon\",\n        \"Alexander Albon\",\n        \"Yuki Tsunoda\",\n        \"Daniel Ricciardo\",\n        \"Nico Hulkenberg\",\n        \"Kevin Magnussen\",\n        \"Valtteri Bottas\",\n        \"Zhou Guanyu\",\n        \"Logan Sargeant\",\n      ]\n\n      driverStandings = drivers.map((name, idx) => {\n        const basePoints = 400 - idx * 25\n        const wins = idx === 0 ? 12 : idx < 3 ? Math.floor(Math.random() * 5) + 1 : Math.floor(Math.random() * 2)\n        const poles = idx === 0 ? 8 : idx < 3 ? Math.floor(Math.random() * 4) : Math.floor(Math.random() * 2)\n\n        return {\n          position: idx + 1,\n          driverId: name.toLowerCase().replace(/ /g, \"_\"),\n          name,\n          points: Math.max(basePoints, 0),\n          wins,\n          poles,\n        }\n      })\n    } else {\n      driverStandings = driverStandings.map((s, idx) => ({\n        position: idx + 1,\n        driverId: s.driverId,\n        name: s.driver ? `${s.driver.forename} ${s.driver.surname}` : \"Unknown\",\n        points: s.points,\n        wins: s.wins || 0,\n        poles: s.poles || 0,\n      }))\n    }\n\n    if (constructorStandings.length === 0) {\n      const teams = [\n        \"Red Bull Racing\",\n        \"Mercedes\",\n        \"Ferrari\",\n        \"McLaren\",\n        \"Aston Martin\",\n        \"Alpine\",\n        \"Williams\",\n        \"AlphaTauri\",\n        \"Alfa Romeo\",\n        \"Haas F1 Team\",\n      ]\n\n      constructorStandings = teams.map((name, idx) => ({\n        position: idx + 1,\n        constructorId: name.toLowerCase().replace(/ /g, \"_\"),\n        name,\n        points: Math.max(600 - idx * 60, 0),\n        wins: idx === 0 ? 15 : idx < 3 ? Math.floor(Math.random() * 5) : Math.floor(Math.random() * 2),\n      }))\n    } else {\n      constructorStandings = constructorStandings.map((s, idx) => ({\n        position: idx + 1,\n        constructorId: s.constructorId,\n        name: s.constructor?.name || \"Unknown\",\n        points: s.points,\n        wins: s.wins || 0,\n      }))\n    }\n\n    return Response.json({\n      success: true,\n      data: {\n        year: yearNum,\n        races: races.map((r) => ({\n          raceId: r.raceId,\n          round: r.round,\n          name: r.name,\n          date: r.date,\n          circuit: r.circuitId,\n        })),\n        driverStandings,\n        constructorStandings,\n        totalRaces: races.length,\n      },\n    })\n  } catch (error) {\n    console.error(\"[API] Error fetching season data:\", error)\n    return Response.json({ success: false, error: \"Failed to fetch season data\" }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":"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"}}]
}