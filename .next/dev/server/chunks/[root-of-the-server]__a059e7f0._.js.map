{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Admin/OneDrive/Pictures/FORMULA%201%20FINAL%20PROJECT/lib/f1-data-loader.ts"],"sourcesContent":["import fs from \"fs\"\nimport path from \"path\"\nimport { parse } from \"csv-parse/sync\"\n\n// Types for F1 data\nexport interface Driver {\n  driverId: number\n  driverRef: string\n  number?: number\n  code?: string\n  forename: string\n  surname: string\n  dob?: string\n  nationality: string\n}\n\nexport interface Constructor {\n  constructorId: number\n  constructorRef: string\n  name: string\n  nationality: string\n}\n\nexport interface Race {\n  raceId: number\n  year: number\n  round: number\n  circuitId: number\n  name: string\n  date: string\n  time?: string\n}\n\nexport interface Result {\n  resultId: number\n  raceId: number\n  driverId: number\n  constructorId: number\n  number?: number\n  grid: number\n  position?: number\n  positionText: string\n  positionOrder: number\n  points: number\n  laps: number\n  time?: string\n  milliseconds?: number\n  fastestLap?: number\n  rank?: number\n  fastestLapTime?: string\n  fastestLapSpeed?: string\n  statusId: number\n}\n\nexport interface Circuit {\n  circuitId: number\n  circuitRef: string\n  name: string\n  location: string\n  country: string\n  lat?: number\n  lng?: number\n  alt?: number\n}\n\nexport interface Season {\n  year: number\n  url?: string\n}\n\nexport interface QualiResult {\n  qualifyId: number\n  raceId: number\n  driverId: number\n  constructorId: number\n  number: number\n  position?: number\n  q1?: string\n  q2?: string\n  q3?: string\n}\n\n// Singleton cache\nlet cachedData: {\n  drivers: Map<number, Driver>\n  constructors: Map<number, Constructor>\n  races: Race[]\n  results: Result[]\n  circuits: Map<number, Circuit>\n  seasons: Season[]\n  qualifying: QualiResult[]\n} | null = null\n\nfunction parseCsvFile<T>(fileName: string): T[] {\n  try {\n    const filePath = path.join(process.cwd(), \"public\", \"data\", fileName)\n\n    if (!fs.existsSync(filePath)) {\n      console.warn(`[F1 Data] CSV file not found: ${fileName}`)\n      return []\n    }\n\n    const fileContent = fs.readFileSync(filePath, \"utf-8\")\n    const records = parse(fileContent, {\n      columns: true,\n      skip_empty_lines: true,\n      cast: (value, context) => {\n        // Auto-convert numeric fields\n        if (context.header) return value\n        if (value === \"\" || value === null) return null\n        if (!isNaN(Number(value)) && value !== \"\") return Number(value)\n        return value\n      },\n    })\n\n    return records as T[]\n  } catch (error) {\n    console.error(`[F1 Data] Error parsing ${fileName}:`, error)\n    return []\n  }\n}\n\nfunction generateMockData() {\n  const mockDrivers = new Map<number, Driver>([\n    [1, { driverId: 1, driverRef: \"hamilton\", forename: \"Lewis\", surname: \"Hamilton\", nationality: \"British\" }],\n    [2, { driverId: 2, driverRef: \"verstappen\", forename: \"Max\", surname: \"Verstappen\", nationality: \"Dutch\" }],\n    [3, { driverId: 3, driverRef: \"alonso\", forename: \"Fernando\", surname: \"Alonso\", nationality: \"Spanish\" }],\n    [4, { driverId: 4, driverRef: \"leclerc\", forename: \"Charles\", surname: \"Leclerc\", nationality: \"Monegasque\" }],\n    [5, { driverId: 5, driverRef: \"sainz\", forename: \"Carlos\", surname: \"Sainz\", nationality: \"Spanish\" }],\n  ])\n\n  const mockConstructors = new Map<number, Constructor>([\n    [1, { constructorId: 1, constructorRef: \"mercedes\", name: \"Mercedes\", nationality: \"German\" }],\n    [2, { constructorId: 2, constructorRef: \"red_bull\", name: \"Red Bull Racing\", nationality: \"Austrian\" }],\n    [3, { constructorId: 3, constructorRef: \"ferrari\", name: \"Ferrari\", nationality: \"Italian\" }],\n    [4, { constructorId: 4, constructorRef: \"mclaren\", name: \"McLaren\", nationality: \"British\" }],\n  ])\n\n  const mockCircuits = new Map<number, Circuit>([\n    [1, { circuitId: 1, circuitRef: \"monza\", name: \"Monza\", location: \"Monza\", country: \"Italy\" }],\n    [2, { circuitId: 2, circuitRef: \"silverstone\", name: \"Silverstone\", location: \"Silverstone\", country: \"UK\" }],\n  ])\n\n  const mockRaces: Race[] = Array.from({ length: 20 }, (_, i) => ({\n    raceId: i + 1,\n    year: 2024,\n    round: i + 1,\n    circuitId: (i % 2) + 1,\n    name: `Grand Prix ${i + 1}`,\n    date: \"2024-01-01\",\n  }))\n\n  const mockResults: Result[] = []\n  const mockSeasons: Season[] = Array.from({ length: 75 }, (_, i) => ({\n    year: 1950 + i,\n  }))\n\n  return {\n    drivers: mockDrivers,\n    constructors: mockConstructors,\n    races: mockRaces,\n    results: mockResults,\n    circuits: mockCircuits,\n    seasons: mockSeasons,\n    qualifying: [],\n  }\n}\n\nexport async function loadF1Data() {\n  // Return cached data if available\n  if (cachedData) {\n    return cachedData\n  }\n\n  try {\n    // Load all CSV files\n    const drivers = parseCsvFile<Driver>(\"drivers.csv\")\n    const constructors = parseCsvFile<Constructor>(\"constructors.csv\")\n    const races = parseCsvFile<Race>(\"races.csv\")\n    const results = parseCsvFile<Result>(\"results.csv\")\n    const circuits = parseCsvFile<Circuit>(\"circuits.csv\")\n    const seasons = parseCsvFile<Season>(\"seasons.csv\")\n    const qualifying = parseCsvFile<QualiResult>(\"qualifying.csv\")\n\n    // Check if we got any real data\n    const hasRealData = drivers.length > 0 || races.length > 0 || results.length > 0\n\n    if (!hasRealData) {\n      console.warn(\"[F1 Data] No CSV files found, using mock data\")\n      cachedData = generateMockData()\n      return cachedData\n    }\n\n    // Create maps for O(1) lookups\n    const driverMap = new Map(drivers.map((d) => [d.driverId, d]))\n    const constructorMap = new Map(constructors.map((c) => [c.constructorId, c]))\n    const circuitMap = new Map(circuits.map((c) => [c.circuitId, c]))\n\n    cachedData = {\n      drivers: driverMap,\n      constructors: constructorMap,\n      races,\n      results,\n      circuits: circuitMap,\n      seasons,\n      qualifying,\n    }\n\n    return cachedData\n  } catch (error) {\n    console.error(\"[F1 Data] Error loading data, using mock data:\", error)\n    cachedData = generateMockData()\n    return cachedData\n  }\n}\n\n// Helper functions\nexport async function getSeasonRaces(year: number) {\n  const data = await loadF1Data()\n  return data.races.filter((r) => r.year === year).sort((a, b) => a.round - b.round)\n}\n\nexport async function getDriverStandings(year: number) {\n  const data = await loadF1Data()\n  const races = await getSeasonRaces(year)\n\n  if (races.length === 0) {\n    return []\n  }\n\n  const raceIds = new Set(races.map((r) => r.raceId))\n\n  const seasonResults = data.results.filter((r) => raceIds.has(r.raceId))\n\n  const standings: Record<number, { driverId: number; points: number; wins: number; poles: number }> = {}\n\n  seasonResults.forEach((result) => {\n    if (!standings[result.driverId]) {\n      standings[result.driverId] = { driverId: result.driverId, points: 0, wins: 0, poles: 0 }\n    }\n    standings[result.driverId].points += result.points\n    if (result.positionOrder === 1) standings[result.driverId].wins++\n  })\n\n  const quali = data.qualifying.filter((q) => raceIds.has(q.raceId))\n  quali.forEach((q) => {\n    if (q.position === 1 && standings[q.driverId]) {\n      standings[q.driverId].poles++\n    }\n  })\n\n  return Object.values(standings)\n    .sort((a, b) => b.points - a.points)\n    .map((standing) => ({\n      ...standing,\n      driver: data.drivers.get(standing.driverId),\n    }))\n}\n\nexport async function getConstructorStandings(year: number) {\n  const data = await loadF1Data()\n  const races = await getSeasonRaces(year)\n\n  if (races.length === 0) {\n    return []\n  }\n\n  const raceIds = new Set(races.map((r) => r.raceId))\n\n  const seasonResults = data.results.filter((r) => raceIds.has(r.raceId))\n\n  const standings: Record<number, { constructorId: number; points: number; wins: number }> = {}\n\n  seasonResults.forEach((result) => {\n    if (!standings[result.constructorId]) {\n      standings[result.constructorId] = { constructorId: result.constructorId, points: 0, wins: 0 }\n    }\n    standings[result.constructorId].points += result.points\n    if (result.positionOrder === 1) standings[result.constructorId].wins++\n  })\n\n  return Object.values(standings)\n    .sort((a, b) => b.points - a.points)\n    .map((standing) => ({\n      ...standing,\n      constructor: data.constructors.get(standing.constructorId),\n    }))\n}\n\nexport async function getDriverCareerStats(driverId: number) {\n  const data = await loadF1Data()\n  const driverResults = data.results.filter((r) => r.driverId === driverId)\n\n  const stats = {\n    wins: driverResults.filter((r) => r.positionOrder === 1).length,\n    podiums: driverResults.filter((r) => r.positionOrder <= 3).length,\n    points: driverResults.reduce((sum, r) => sum + r.points, 0),\n    races: driverResults.length,\n    dnfs: driverResults.filter((r) => !r.position || r.position === null).length,\n  }\n\n  return stats\n}\n\nexport async function getConstructorCareerStats(constructorId: number) {\n  const data = await loadF1Data()\n  const constructorResults = data.results.filter((r) => r.constructorId === constructorId)\n\n  const stats = {\n    wins: constructorResults.filter((r) => r.positionOrder === 1).length,\n    championships: 0, // Would need season-based logic\n    points: constructorResults.reduce((sum, r) => sum + r.points, 0),\n    races: constructorResults.length,\n  }\n\n  return stats\n}\n\nexport async function getAllTimeRecords() {\n  const data = await loadF1Data()\n\n  // Most wins by driver\n  const driverWins = new Map<number, number>()\n  data.results.forEach((r) => {\n    if (r.positionOrder === 1) {\n      driverWins.set(r.driverId, (driverWins.get(r.driverId) || 0) + 1)\n    }\n  })\n\n  // Most wins by constructor\n  const constructorWins = new Map<number, number>()\n  data.results.forEach((r) => {\n    if (r.positionOrder === 1) {\n      constructorWins.set(r.constructorId, (constructorWins.get(r.constructorId) || 0) + 1)\n    }\n  })\n\n  // Most poles by driver\n  const driverPoles = new Map<number, number>()\n  data.qualifying.forEach((q) => {\n    if (q.position === 1) {\n      driverPoles.set(q.driverId, (driverPoles.get(q.driverId) || 0) + 1)\n    }\n  })\n\n  return {\n    driverWins: Array.from(driverWins.entries())\n      .map(([driverId, wins]) => ({ driverId, wins, driver: data.drivers.get(driverId) }))\n      .sort((a, b) => b.wins - a.wins)\n      .slice(0, 20),\n    constructorWins: Array.from(constructorWins.entries())\n      .map(([constructorId, wins]) => ({ constructorId, wins, constructor: data.constructors.get(constructorId) }))\n      .sort((a, b) => b.wins - a.wins)\n      .slice(0, 15),\n    driverPoles: Array.from(driverPoles.entries())\n      .map(([driverId, poles]) => ({ driverId, poles, driver: data.drivers.get(driverId) }))\n      .sort((a, b) => b.poles - a.poles)\n      .slice(0, 20),\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;AAgFA,kBAAkB;AAClB,IAAI,aAQO;AAEX,SAAS,aAAgB,QAAgB;IACvC,IAAI;QACF,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,UAAU,QAAQ;QAE5D,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,WAAW;YAC5B,QAAQ,IAAI,CAAC,CAAC,8BAA8B,EAAE,UAAU;YACxD,OAAO,EAAE;QACX;QAEA,MAAM,cAAc,wGAAE,CAAC,YAAY,CAAC,UAAU;QAC9C,MAAM,UAAU,IAAA,+NAAK,EAAC,aAAa;YACjC,SAAS;YACT,kBAAkB;YAClB,MAAM,CAAC,OAAO;gBACZ,8BAA8B;gBAC9B,IAAI,QAAQ,MAAM,EAAE,OAAO;gBAC3B,IAAI,UAAU,MAAM,UAAU,MAAM,OAAO;gBAC3C,IAAI,CAAC,MAAM,OAAO,WAAW,UAAU,IAAI,OAAO,OAAO;gBACzD,OAAO;YACT;QACF;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,wBAAwB,EAAE,SAAS,CAAC,CAAC,EAAE;QACtD,OAAO,EAAE;IACX;AACF;AAEA,SAAS;IACP,MAAM,cAAc,IAAI,IAAoB;QAC1C;YAAC;YAAG;gBAAE,UAAU;gBAAG,WAAW;gBAAY,UAAU;gBAAS,SAAS;gBAAY,aAAa;YAAU;SAAE;QAC3G;YAAC;YAAG;gBAAE,UAAU;gBAAG,WAAW;gBAAc,UAAU;gBAAO,SAAS;gBAAc,aAAa;YAAQ;SAAE;QAC3G;YAAC;YAAG;gBAAE,UAAU;gBAAG,WAAW;gBAAU,UAAU;gBAAY,SAAS;gBAAU,aAAa;YAAU;SAAE;QAC1G;YAAC;YAAG;gBAAE,UAAU;gBAAG,WAAW;gBAAW,UAAU;gBAAW,SAAS;gBAAW,aAAa;YAAa;SAAE;QAC9G;YAAC;YAAG;gBAAE,UAAU;gBAAG,WAAW;gBAAS,UAAU;gBAAU,SAAS;gBAAS,aAAa;YAAU;SAAE;KACvG;IAED,MAAM,mBAAmB,IAAI,IAAyB;QACpD;YAAC;YAAG;gBAAE,eAAe;gBAAG,gBAAgB;gBAAY,MAAM;gBAAY,aAAa;YAAS;SAAE;QAC9F;YAAC;YAAG;gBAAE,eAAe;gBAAG,gBAAgB;gBAAY,MAAM;gBAAmB,aAAa;YAAW;SAAE;QACvG;YAAC;YAAG;gBAAE,eAAe;gBAAG,gBAAgB;gBAAW,MAAM;gBAAW,aAAa;YAAU;SAAE;QAC7F;YAAC;YAAG;gBAAE,eAAe;gBAAG,gBAAgB;gBAAW,MAAM;gBAAW,aAAa;YAAU;SAAE;KAC9F;IAED,MAAM,eAAe,IAAI,IAAqB;QAC5C;YAAC;YAAG;gBAAE,WAAW;gBAAG,YAAY;gBAAS,MAAM;gBAAS,UAAU;gBAAS,SAAS;YAAQ;SAAE;QAC9F;YAAC;YAAG;gBAAE,WAAW;gBAAG,YAAY;gBAAe,MAAM;gBAAe,UAAU;gBAAe,SAAS;YAAK;SAAE;KAC9G;IAED,MAAM,YAAoB,MAAM,IAAI,CAAC;QAAE,QAAQ;IAAG,GAAG,CAAC,GAAG,IAAM,CAAC;YAC9D,QAAQ,IAAI;YACZ,MAAM;YACN,OAAO,IAAI;YACX,WAAW,AAAC,IAAI,IAAK;YACrB,MAAM,CAAC,WAAW,EAAE,IAAI,GAAG;YAC3B,MAAM;QACR,CAAC;IAED,MAAM,cAAwB,EAAE;IAChC,MAAM,cAAwB,MAAM,IAAI,CAAC;QAAE,QAAQ;IAAG,GAAG,CAAC,GAAG,IAAM,CAAC;YAClE,MAAM,OAAO;QACf,CAAC;IAED,OAAO;QACL,SAAS;QACT,cAAc;QACd,OAAO;QACP,SAAS;QACT,UAAU;QACV,SAAS;QACT,YAAY,EAAE;IAChB;AACF;AAEO,eAAe;IACpB,kCAAkC;IAClC,IAAI,YAAY;QACd,OAAO;IACT;IAEA,IAAI;QACF,qBAAqB;QACrB,MAAM,UAAU,aAAqB;QACrC,MAAM,eAAe,aAA0B;QAC/C,MAAM,QAAQ,aAAmB;QACjC,MAAM,UAAU,aAAqB;QACrC,MAAM,WAAW,aAAsB;QACvC,MAAM,UAAU,aAAqB;QACrC,MAAM,aAAa,aAA0B;QAE7C,gCAAgC;QAChC,MAAM,cAAc,QAAQ,MAAM,GAAG,KAAK,MAAM,MAAM,GAAG,KAAK,QAAQ,MAAM,GAAG;QAE/E,IAAI,CAAC,aAAa;YAChB,QAAQ,IAAI,CAAC;YACb,aAAa;YACb,OAAO;QACT;QAEA,+BAA+B;QAC/B,MAAM,YAAY,IAAI,IAAI,QAAQ,GAAG,CAAC,CAAC,IAAM;gBAAC,EAAE,QAAQ;gBAAE;aAAE;QAC5D,MAAM,iBAAiB,IAAI,IAAI,aAAa,GAAG,CAAC,CAAC,IAAM;gBAAC,EAAE,aAAa;gBAAE;aAAE;QAC3E,MAAM,aAAa,IAAI,IAAI,SAAS,GAAG,CAAC,CAAC,IAAM;gBAAC,EAAE,SAAS;gBAAE;aAAE;QAE/D,aAAa;YACX,SAAS;YACT,cAAc;YACd;YACA;YACA,UAAU;YACV;YACA;QACF;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kDAAkD;QAChE,aAAa;QACb,OAAO;IACT;AACF;AAGO,eAAe,eAAe,IAAY;IAC/C,MAAM,OAAO,MAAM;IACnB,OAAO,KAAK,KAAK,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK,MAAM,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK;AACnF;AAEO,eAAe,mBAAmB,IAAY;IACnD,MAAM,OAAO,MAAM;IACnB,MAAM,QAAQ,MAAM,eAAe;IAEnC,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,OAAO,EAAE;IACX;IAEA,MAAM,UAAU,IAAI,IAAI,MAAM,GAAG,CAAC,CAAC,IAAM,EAAE,MAAM;IAEjD,MAAM,gBAAgB,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,QAAQ,GAAG,CAAC,EAAE,MAAM;IAErE,MAAM,YAA+F,CAAC;IAEtG,cAAc,OAAO,CAAC,CAAC;QACrB,IAAI,CAAC,SAAS,CAAC,OAAO,QAAQ,CAAC,EAAE;YAC/B,SAAS,CAAC,OAAO,QAAQ,CAAC,GAAG;gBAAE,UAAU,OAAO,QAAQ;gBAAE,QAAQ;gBAAG,MAAM;gBAAG,OAAO;YAAE;QACzF;QACA,SAAS,CAAC,OAAO,QAAQ,CAAC,CAAC,MAAM,IAAI,OAAO,MAAM;QAClD,IAAI,OAAO,aAAa,KAAK,GAAG,SAAS,CAAC,OAAO,QAAQ,CAAC,CAAC,IAAI;IACjE;IAEA,MAAM,QAAQ,KAAK,UAAU,CAAC,MAAM,CAAC,CAAC,IAAM,QAAQ,GAAG,CAAC,EAAE,MAAM;IAChE,MAAM,OAAO,CAAC,CAAC;QACb,IAAI,EAAE,QAAQ,KAAK,KAAK,SAAS,CAAC,EAAE,QAAQ,CAAC,EAAE;YAC7C,SAAS,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK;QAC7B;IACF;IAEA,OAAO,OAAO,MAAM,CAAC,WAClB,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,MAAM,GAAG,EAAE,MAAM,EAClC,GAAG,CAAC,CAAC,WAAa,CAAC;YAClB,GAAG,QAAQ;YACX,QAAQ,KAAK,OAAO,CAAC,GAAG,CAAC,SAAS,QAAQ;QAC5C,CAAC;AACL;AAEO,eAAe,wBAAwB,IAAY;IACxD,MAAM,OAAO,MAAM;IACnB,MAAM,QAAQ,MAAM,eAAe;IAEnC,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,OAAO,EAAE;IACX;IAEA,MAAM,UAAU,IAAI,IAAI,MAAM,GAAG,CAAC,CAAC,IAAM,EAAE,MAAM;IAEjD,MAAM,gBAAgB,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,QAAQ,GAAG,CAAC,EAAE,MAAM;IAErE,MAAM,YAAqF,CAAC;IAE5F,cAAc,OAAO,CAAC,CAAC;QACrB,IAAI,CAAC,SAAS,CAAC,OAAO,aAAa,CAAC,EAAE;YACpC,SAAS,CAAC,OAAO,aAAa,CAAC,GAAG;gBAAE,eAAe,OAAO,aAAa;gBAAE,QAAQ;gBAAG,MAAM;YAAE;QAC9F;QACA,SAAS,CAAC,OAAO,aAAa,CAAC,CAAC,MAAM,IAAI,OAAO,MAAM;QACvD,IAAI,OAAO,aAAa,KAAK,GAAG,SAAS,CAAC,OAAO,aAAa,CAAC,CAAC,IAAI;IACtE;IAEA,OAAO,OAAO,MAAM,CAAC,WAClB,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,MAAM,GAAG,EAAE,MAAM,EAClC,GAAG,CAAC,CAAC,WAAa,CAAC;YAClB,GAAG,QAAQ;YACX,aAAa,KAAK,YAAY,CAAC,GAAG,CAAC,SAAS,aAAa;QAC3D,CAAC;AACL;AAEO,eAAe,qBAAqB,QAAgB;IACzD,MAAM,OAAO,MAAM;IACnB,MAAM,gBAAgB,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;IAEhE,MAAM,QAAQ;QACZ,MAAM,cAAc,MAAM,CAAC,CAAC,IAAM,EAAE,aAAa,KAAK,GAAG,MAAM;QAC/D,SAAS,cAAc,MAAM,CAAC,CAAC,IAAM,EAAE,aAAa,IAAI,GAAG,MAAM;QACjE,QAAQ,cAAc,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE;QACzD,OAAO,cAAc,MAAM;QAC3B,MAAM,cAAc,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,QAAQ,IAAI,EAAE,QAAQ,KAAK,MAAM,MAAM;IAC9E;IAEA,OAAO;AACT;AAEO,eAAe,0BAA0B,aAAqB;IACnE,MAAM,OAAO,MAAM;IACnB,MAAM,qBAAqB,KAAK,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,aAAa,KAAK;IAE1E,MAAM,QAAQ;QACZ,MAAM,mBAAmB,MAAM,CAAC,CAAC,IAAM,EAAE,aAAa,KAAK,GAAG,MAAM;QACpE,eAAe;QACf,QAAQ,mBAAmB,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE;QAC9D,OAAO,mBAAmB,MAAM;IAClC;IAEA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IAEnB,sBAAsB;IACtB,MAAM,aAAa,IAAI;IACvB,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;QACpB,IAAI,EAAE,aAAa,KAAK,GAAG;YACzB,WAAW,GAAG,CAAC,EAAE,QAAQ,EAAE,CAAC,WAAW,GAAG,CAAC,EAAE,QAAQ,KAAK,CAAC,IAAI;QACjE;IACF;IAEA,2BAA2B;IAC3B,MAAM,kBAAkB,IAAI;IAC5B,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;QACpB,IAAI,EAAE,aAAa,KAAK,GAAG;YACzB,gBAAgB,GAAG,CAAC,EAAE,aAAa,EAAE,CAAC,gBAAgB,GAAG,CAAC,EAAE,aAAa,KAAK,CAAC,IAAI;QACrF;IACF;IAEA,uBAAuB;IACvB,MAAM,cAAc,IAAI;IACxB,KAAK,UAAU,CAAC,OAAO,CAAC,CAAC;QACvB,IAAI,EAAE,QAAQ,KAAK,GAAG;YACpB,YAAY,GAAG,CAAC,EAAE,QAAQ,EAAE,CAAC,YAAY,GAAG,CAAC,EAAE,QAAQ,KAAK,CAAC,IAAI;QACnE;IACF;IAEA,OAAO;QACL,YAAY,MAAM,IAAI,CAAC,WAAW,OAAO,IACtC,GAAG,CAAC,CAAC,CAAC,UAAU,KAAK,GAAK,CAAC;gBAAE;gBAAU;gBAAM,QAAQ,KAAK,OAAO,CAAC,GAAG,CAAC;YAAU,CAAC,GACjF,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,IAAI,GAAG,EAAE,IAAI,EAC9B,KAAK,CAAC,GAAG;QACZ,iBAAiB,MAAM,IAAI,CAAC,gBAAgB,OAAO,IAChD,GAAG,CAAC,CAAC,CAAC,eAAe,KAAK,GAAK,CAAC;gBAAE;gBAAe;gBAAM,aAAa,KAAK,YAAY,CAAC,GAAG,CAAC;YAAe,CAAC,GAC1G,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,IAAI,GAAG,EAAE,IAAI,EAC9B,KAAK,CAAC,GAAG;QACZ,aAAa,MAAM,IAAI,CAAC,YAAY,OAAO,IACxC,GAAG,CAAC,CAAC,CAAC,UAAU,MAAM,GAAK,CAAC;gBAAE;gBAAU;gBAAO,QAAQ,KAAK,OAAO,CAAC,GAAG,CAAC;YAAU,CAAC,GACnF,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK,EAChC,KAAK,CAAC,GAAG;IACd;AACF"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Admin/OneDrive/Pictures/FORMULA%201%20FINAL%20PROJECT/app/api/records/route.ts"],"sourcesContent":["import { getAllTimeRecords } from \"@/lib/f1-data-loader\"\n\nexport async function GET() {\n  try {\n    const records = await getAllTimeRecords()\n\n    return Response.json({\n      success: true,\n      data: {\n        mostWinsDrivers: records.driverWins.map((item, idx) => ({\n          position: idx + 1,\n          driverId: item.driverId,\n          name: item.driver ? `${item.driver.forename} ${item.driver.surname}` : \"Unknown\",\n          wins: item.wins,\n        })),\n        mostWinsConstructors: records.constructorWins.map((item, idx) => ({\n          position: idx + 1,\n          constructorId: item.constructorId,\n          name: item.constructor?.name || \"Unknown\",\n          wins: item.wins,\n        })),\n        mostPolesDrivers: records.driverPoles.map((item, idx) => ({\n          position: idx + 1,\n          driverId: item.driverId,\n          name: item.driver ? `${item.driver.forename} ${item.driver.surname}` : \"Unknown\",\n          poles: item.poles,\n        })),\n      },\n    })\n  } catch (error) {\n    console.error(\"[API] Error fetching records:\", error)\n    return Response.json({ success: false, error: \"Failed to fetch records\" }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,kJAAiB;QAEvC,OAAO,SAAS,IAAI,CAAC;YACnB,SAAS;YACT,MAAM;gBACJ,iBAAiB,QAAQ,UAAU,CAAC,GAAG,CAAC,CAAC,MAAM,MAAQ,CAAC;wBACtD,UAAU,MAAM;wBAChB,UAAU,KAAK,QAAQ;wBACvB,MAAM,KAAK,MAAM,GAAG,GAAG,KAAK,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,OAAO,EAAE,GAAG;wBACvE,MAAM,KAAK,IAAI;oBACjB,CAAC;gBACD,sBAAsB,QAAQ,eAAe,CAAC,GAAG,CAAC,CAAC,MAAM,MAAQ,CAAC;wBAChE,UAAU,MAAM;wBAChB,eAAe,KAAK,aAAa;wBACjC,MAAM,KAAK,WAAW,EAAE,QAAQ;wBAChC,MAAM,KAAK,IAAI;oBACjB,CAAC;gBACD,kBAAkB,QAAQ,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,MAAQ,CAAC;wBACxD,UAAU,MAAM;wBAChB,UAAU,KAAK,QAAQ;wBACvB,MAAM,KAAK,MAAM,GAAG,GAAG,KAAK,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,OAAO,EAAE,GAAG;wBACvE,OAAO,KAAK,KAAK;oBACnB,CAAC;YACH;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,SAAS,IAAI,CAAC;YAAE,SAAS;YAAO,OAAO;QAA0B,GAAG;YAAE,QAAQ;QAAI;IAC3F;AACF"}}]
}